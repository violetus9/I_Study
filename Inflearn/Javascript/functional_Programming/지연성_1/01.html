<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>range와 느긋한 L.range</title>
</head>

<body>

  <script src="../지연성_1/fx.js"></script>

  ## range
  <script>

    // 간단한 range함수를 구현해보자
    // 숫자 하나 받고 숫자크기의 배열 리턴할거임
    const range = l => {
      let i = -1;
      let res = [];
      while (++i < l) {
        log(i, 'range');
        res.push(i);
      }
      return res;
    };

    log(range(5));
    // [0, 1, 2, 3, 4]

    log(range(2));
    // [0, 1]

    // 배열의 모든 값들을 더해보쟈
    const add = (a, b) => a + b;

    let list = range(4);
    log(list);
    log(reduce(add, list)); // 안의 모든 값을 더하겠쪼

  </script>

  ## 느긋한 L.range
  <script>

    // 위와 똑같은 행위를 느긋한~ 만들어 보겠어
    const L = {};
    L.range = function* (l) {
      let i = -1;
      while (++i < l) {
        log(i, 'L.range');
        yield i;
      }
    };  // 이터레이터 만드는 제너레이터 선언했고, i가 증가케끔

    const add = (a, b) => a + b;

    let list = range(4);
    log(list);
    log(list.next());
    log(list.next());
    // log(reduce(add, list));

    // 위 range와 차이를 보자면 위는 배열출력이고 아래는 L.range {<suspended>} 라 나오는데 이건 이터레이터
    // next()로 값을 가져올 수 있는 이터레이터인데요~ 같은결과입니다 왜냐면
    // reduce가 이터러블을 받기 때문입니다. 그말인즉슨 배열도 이터러블이고 이터레이터도 이터러블이기 때문입니다
    // 근디 차이가 있는데요 위 range같은 경우 reduce의 리스트를 전달하기 전에 range를 실행했을 때, list변수에 담긴 값이 배열인 상태입니다.
    // range를 실행했을 때, 배열로 완전히 평가가 되었다는거고

    // L.range 경우에는 log찍은게 전~혀 실행되지 않았다.
    // 그럼 언제 평가되는데 ? >> 내부의 값을 처음 순회할 때, 결과가 꺼내짐

    // 결론은 range는 array를 다 만든 다음 배열로 전달이 돼서 동작이 되고
    // L.range는 array를 만들지 않고 하나씩 값을 꺼내게 되는거대

  </script>

</body>

</html>