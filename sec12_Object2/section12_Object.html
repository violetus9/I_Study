<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>객체</title>
</head>

<body>

  <!-- class를 통한 객체생성 -->
  <script>

    // ES6 Class
    function Health(name) {
      this.name = name;
    }

    Health.prototype.showHealth = function () {
      console.log(this.name + '님 안녕하세요');
    }
    // 이렇게 헬스라는 클래스에 이름만으로 출력해씀

    const h = new Health('crong');
    h.showHealth();
    // 이게 일반적인 클래스 형태
    // 즉, 효율적인 객체를 프로토타입안에 두면서 객체를 제너레이트 하는, new키워드를 부를 때, prototype하위의, this추가한거 모두를 묶어 할당한것
    // constructor도 없고 일반적 객체와는 다르지만, ES6 클래스는 호불호가 갈리지만 가독성에서는 좀 좋대

    // 위와 같은 형태임
    // 이 헬스도 사실 모습만 클래스일 뿐이지 내부적으로는 함수로 처리가 됨 ㅇㅇ 그정도
    // 결국 프로토타입이랑 연결되어있다는 그런
    class Health1 {
      constructor(name, lastTime) {
        this.name = name;
        this.lastTime = lastTime;
      }
      showHealth() {
        console.log('안녕하세요' + this.name);
      }
    }
    const myHealth = new Health1('crom');
    myHealth.showHealth();
    // 실행후 객체 열어보면 프로토타입 하위항목으로 메서드 들어가있는거 보여
    // 타입체크를 해보까
    console.log(toString.call(Health1));    // object Function >> 클래스가 아니래 ㅋ
    // 허나 이런식으로 클래스를 짜두면 가독성도 좋고 협업시 이런 코드패턴이 좋다고~ 할 수 있다

  </script>

  <!-- Object assign으로 JS객체 만들기 -->
  <script>

    // Object assign 메서드
    // assign 이전에 create 부터 알아보자
    // new를 통해 만들었었는데 이게 좀 아니다 싶었는지 순수한 obj만들 수 없나~해서
    const healthObj = {
      showHealth2: function () {
        console.log(`오늘 운동시간 ${this.healthTime}`);
      }
    }
    // const myHealth2 = Object.create(healthObj);

    // myHealth2.healthTime = '11:20';
    // myHealth2.name = 'ppo';

    // console.log(myHealth2);
    // 보면 오브젝트 형태로 나온다 열어보면 값들 나오고 프로토 나옴
    // 마이헬스2가 프로토타입에 들어가있따 일반 오브젝트가 아닌 >> obj 크리에이트로 쉽게 객체를 만들 수 있다
    // js obj 객체를 만드는 가장 표준적인 방법이라고 알고 있어라
    // 헌데 이런 값(name...)들을 따로 추가해줘야 한다는 점이 .. 불편 >> assign 메서드 쓰면 이부분 개선

    const myHealth2 = Object.assign(Object.create(healthObj), {
      name: 'ppoo',
      lastTime: '11:23'
    });
    console.log(`myHealth2 is  ${myHealth2}`);

  </script>

  <!-- Object assign으로 Immutable 객체만들기 -->
  <script>

    // Object assign 메서드
    // obj assign은 사실 immutable 객체를 만드는 방법이기도 하다
    const previousObj = {
      name: 'abcd',
      lastTime: '12:12'
    };    // 이전의 객체가 이런게 있다 쳐보자
    // 현재는 프로토타입 필요 없으니까 빈 오브젝트 만들고
    const myHealth3 = Object.assign({}, previousObj, {
      'lastTime': '12:30',
      'age': 99
    });
    console.log(`myHealth2 is  ${myHealth2}`);
    // 이전값과 비교해서 새로운거 대체하고 아니면 그대로 써주게되는 모습

    console.log(previousObj === myHealth3); // false 근데 아무것도 3에 지정 않으면 true가 나오겠찌? >> 근데 false가 나오게됨
    // obj assign 잘 활용하면 객체를 복사? 해서 새로운 객체를 생성해서 비교든 뭐든 잘 활용할 수 있어
    // 혹은 히스토리를 저장키 위해서 되돌리기나 그런게 가능토록 할 수 이씀

  </script>

  <!-- Object setPrototypeOf로 객체만들기 -->
  <script>

    const healthObj4 = {
      showHealth2: function () {
        console.log(`오늘 운동시간 ${this.healthTime}`);
      },
      setHealth: function (newTime) {
        this.healthTime = newTime;
      }
    }

    // setPrototypeOf : ~~의 프로토타입으로 세팅하겠다(프로토타입 객체에만 추가하겠다) >> 명확하고 단순한 기능 유지
    const myHealth4 = {
      name: 'cronh',
      lastTime: '15:20'
    };
    Object.setPrototypeOf(myHealth4, healthObj4);  // myH4객체에 프로토타입으로 ~Obj를 지정해줘~ 라는 말
    console.log(`myHealth4 is ${myHealth4}`);



  </script>

</body>

</html>