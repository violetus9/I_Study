## 동시성 모델과 이벤트 루프

자바스크립트는 이벤트 루프에 기반한 동시성 모델을 가지고 있다.

이 모델은 C나 Java와는 완전히 다른 모델이며 이벤트 루프는 코드 실행, 이벤트의 수집과 처리, 큐에 놓인 하위 작업을 담당한다.

<br>

무슨말이냐고?

자바스크립트는 싱글 스레드 기반의 언어이다. 단일 Call Stack을 사용하기 때문이다. 하지만 실제론 많은 작업이 동시에 처리되는 모습을 볼 수 있는데 이를 가능케 하는 것이 이벤트 루프이며 이 이벤트 루프를 통해 비동기 방식으로 동시성을 지원한다는 것이다.

- _`Block`: 다른 작업을 실행하기 위해 이 전 작업 완료를 기다려야 하는 상황_

더 확실히 하기 위해 자바스크립트 엔진에 대해 알 필요가 있다.

<br>

### Javascript Engine

자바스크립트 엔진은 인터프리터로 JS코드를 해석하고 실행한다. nodejs의 등장으로 서버딴에선 V8과 같은 엔진이 이용된다.

_(크로스 브라우징 할 때 봤던 렌더링 엔진과는 다른 거임)_

아무튼 이 자바스크립트 엔진은 Stack, Heap 영역을 갖는다.

<br>

### Stack, Heap, Queue(엔진 외부)

- Stack

  함수 호출은 프레임들의 스택을 형성한다.

  ```js
  function foo(b) {
  	let a = 10;
  	return a + b + 11;
  }

  function bar(x) {
  	let y = 3;
  	return foo(x * y);
  }

  console.log(bar(7)); // 42
  ```

  bar 호출 시 bar의 인자와 지역 변수를 포함하는 첫 프레임이 형성된다.

  bar가 foo를 호출하면 두 번째 프레임이 형성되고 foo의 인자와 지역 변수가 들어 있는 프레임을 스택에 푸시한다.

  foo 가 반환되면 스택 밖으로 빠져나오게 되고 bar의 요소가 최상위 프레임으로 된다.

  흔히 우리가 아는 스택 그 방식인것.

<br>

- Heap

  객체들은 힙 내부에 할당된다. 구조화 되지 않은 넓은 메모리 영역을 힙이라 칭한다.

<br>

- (Event | Task) Queue

  _얘는 엄연히 엔진 외부 영역에 구현되어 있댄다._

  JS 런타임은 처리 할 메시지 목록 개념으로 대기열을 사용한다.

  각 메시지는 그를 처리하기 위해 호출되는 관련 함수가 포함된다.

  이벤트 루프중 어느 시점에서 런타임은, 대기열의 가장 오래된 메시지부터 처리하기 시작한다. 이 과정에 메시지는 큐에서 제거되며 함수를 처리하기 위한 새로운 스택 프레임을 형성한다.

  함수의 처리는 스택이 다시 비워질 때까지 진행되며 이벤트 루프는 큐의 다음 메시지를 처리한다.

<br>

### Event Loop

추가적으로 엔진 외부 영역에 존재하는 애다.

주로 하는 일은 Task queue(Event queue라고도 함)에 들어가는 task들을 관리한다.

다시말해, 스택이 비워졌을때 큐에 있는 순서대로 채워넣는 일을 하는 친구다.

다음과 유사하게 처리한다.

```js
while (queue.waitForMessage()) {
	queue.processNextMessage();
}
```

queue.waitForMessage() 함수는 현재 아무런 메시지가 없다면 새로운 메시지 도착을 동기적으로 기다린다.

<br>

- Web API 영역의 존재

  3영역 외에 브라우저엔 Web API란 영역이 존재한다.

  이 영역은 Web API같은 것들을 제공해 비동기 작업을 가능하게 해준다. (비동기 콜백)

  DOM(document), AJAX(XMLHttpRequest), setTimeout 같은 애들이 이 영역에 포함된다.

<br>

### 그래서 어떻게 구동되는데?

앞서 얘기한 세 영역과 Web API 영역, 이벤트 루프라는 개념을 알고 있으면 충분히 이해할 수 있다.

코드를 보자 (_각 영역을 어디 좀 그려놓고 절차대로 따라해보셍 이해확댐_)

```js
console.log(1);

setTimeout(function cb() {
	console.log(2);
}, 3000);

console.log(3);
```

1. 메인 함수 실행 후 console.log(1)이 스택에 쌓인다.
2. console.log(1)은 결과를 출력 후 스택에서 사라진다.
3. setTimeout의 콜백 함수가 스택에 쌓인다.
4. 브라우저로 역할을 위임한다(setTimeout은 엔진영역 ㄴㄴ)
5. console.log(3)을 스택에 쌓고 결과를 출력하며 스택에서 사라진다.

6. 모든 코드가 실행되었으므로 main() 함수가 스택에서 제거된다.
7. 웹 영역에서 대기하던 api는 3초가 지난 시점에서 queue로 진입한다.
8. 스택이 비어있으므로 콜백 함수를 스택에 쌓고 console.log(2) 절차를 진행한다.

9. 출력 결과 1 > 3 > (3초후) > 2

모든 Web API(AJAX, DOM 이런애들)의 동작 방식도 마찬가지 입니다.

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

추가로 봐야할 개념

- debouncing

그리고 링크

- https://meetup.toast.com/posts/89
- https://ui.toast.com/weekly-pick/ko_20200228
