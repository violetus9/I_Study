## Compile

Javascript는 스크립트 언어이자 인터프리터 언어이고 컴파일이 가능하다. JS의 컴파일레이션은 코드가 실행되기 직전 순간 일어나며 Just in time이라고 표현한다.

Interpreter: 코드를 읽어나가며 해석, 실행  
Compile: A 언어로 작성된 코드를 다른 언어로 변환하는 것.

<br>

### 컴파일레이션 3단계

JS코드는 크게 3단계로 컴파일 된다.

1. 토크나이징 / 렉싱: 코드를 의미있는 조각(token)으로 만드는 과정
   (ex. var a = 2 -> var, a =, 2)

2. 파싱: 문법 구조를 반영, 중첩 원소를 갖는 트리 형태로 바꾸는 과정. 파싱 결과로 만들어진 트리를 AST(추상 구문 트리)라 한다.

3. 코드 생성: AST를 실행 코드(기계어)로 바꾸는 과정

<br>

### 엔진, 컴파일러, 스코프

컴파일 관점에서 코드의 실행으로 관점을 옮겨보면 엔진과 컴파일러, 스코프가 상호 작용하게 된다.

- **엔진**: 컴파일레이션 시작부터 끝까지 모든 과정과 프로그램 실행을 책임진다.  
  (런타임 환경을 실질적으로 엔진이 담당한다~라 볼 수 있는 것.)

- **컴파일러**: 파싱, 코드 생성 등(컴파일레이션)

- **스코프**: 선언된 변수 목록을 작성하고 유지한다.

<br>

### 구문의 실행

`var a = 2;`라는 코드가 어떻게 실행되는지 봅시다.

1. 컴파일러가 `var a`를 만나면 스코프 내부에 변수 `a`가 있는지 체크한다.

2. 있다면 선언을 무시하며, 없다면 `a`를 선언할 것을 요청한다.

3. 이 후 컴파일러는 `a = 2` 대입문을 처리하기 위해서 엔진이 실행할 수 있도록 코드를 구성한다.

4. 엔진이 실행하는 코드는 먼저 스코프에 `a`라는 변수가 현 스코프 내부에서 접근이 가능한가를 확인하고

5. 접근이 가능하다면 엔진은 변수 `a`를 사용, 반대인 경우 상위 스코프에서 접근 여부를 탐색한다.

6. 글로벌 스코프에서도 찾지 못했을 경우 에러를 발생시킨다.

<br>

### LHS, RHS

컴파일러가 생성한 코드를 실행할 때, 엔진은 변수 `a`가 생성된 바 있는가를 스코프에서 검색한다.

검색 과정에서 `LHS`, `RHS` 검색으로 스코프를 탐색한다.

LHS는 할당한다는 느낌의 개념이며  
RHS는 변수나 어느 참조가 사용될 때, 어딘가의 값을 탐색하는 행위라 볼 수 있다.

코드를 통해 알아보자.

```js
function foo(a) {
	console.log(a);
}
foo(2);
```

1. foo(2)가 실행됨에 참조할 수 있는 foo 함수가 있는지 `RHS` 탐색.

2. 스코프에 참조 가능한 foo가 있다. => 오류 없이 foo(2)를 실행.

3. foo의 파라미터 a는 `LHS` 검색으로 foo(a = 2)처럼 할당.

4. 참조할 수 있는 console 객체가 있는지 `RHS` 탐색.

5. console은 글로벌 스코프에 선언되었다. 오류없이 실행.

6. console.log의 파라미터 a는 console.log(a = 2) `LHS`로 할당.
