## JS Runtime

런타임이란 것은 프로그래밍 언어가 구동되는 환경을 얘기하며 여기서는 자바스크립트의 런타임을 다뤄볼 것이다.

대표적으로 Node.js나 브라우저같은 환경을 대표적인 예로 들 수 있다.

**JS런타임**

JS의 런타임은 다음과 같이 구성되어 있다.

- 자바스크립트 엔진

  - 메모리 힙

  - 콜 스택

- 웹 api

- 이벤트 루프

- 콜백 큐

<br>
<br>

### Memory Heap & Call Stack

JS 엔진이 구동되며 코드를 읽고 실행하는 과정서 중요한 두가지 단계가 있다.

1. 정보(ex. 변수, 함수 등)를 특정 장소에 저장.
2. 현재 실제로 실행되는 코드를 트래킹하는 작업.

여기서 정보를 저장하는 공간(Memory Allocation 발생하는 공간)이 `Memory Heap`이고 코드를 트래킹하는 공간을 `Call Stack`이라 한다.

<br>

**Memory Heap**

변수, 함수 저장, 호출 등의 작업이 발생하는 공간.

쉽게 생각해서 라벨을 붙여 대상을 분류하는 공간이라 생각하면 된다.

<br>

**Call Stack**

메모리에 존재하는 공간 중 하나.

코드를 읽어내려가며 수행할 작업들을 스택으로 쌓아가고 Memory Heap에서 작업 수행에 필요한 것들을 찾아 작업을 수행한다.

- **Stack Overflow**

  만약 재귀적으로든 무수히 많은 콜백 함수든 적절한 반환점을 설정하지 않으면 스택은 계속 쌓이게 된다. 이 때 스택이 한계치 이상 쌓이게 되는 경우 Stack Overflow가 발생하게 된다.

<br>

**Garbage Collector**

Call Stack과 Memory Heap은 한정적인 공간을 가진다. 그렇기 때문에 코드의 효율성이 중요하다. 이 때 자원에 대한 효율적인 관리를 돕는 것이 `GC`이다.

Javascript는 공간의 효율적 관리를 위해 더이상 실효성을 가지지 못하는 변수나 함수 등을 Memory Heap에서 제거하는 동작을 취한다.

대표적으로 GC는 `Mark and Sweep` 이란 알고리즘을 사용한다.

참조를 유지하는 항목에대해 Mark를 수행하고 참조를 갖지 않는 객체에 대해 Sweep 작업을 수행한다.

<br>

**Memory Leak**

Memory Heap이 제대로 관리되지 않는 경우 공간을 초과하는 범위에 정보를 담게 되는데 이를 Memory Leak이라 한다.

과거에 사용되었으나 현재 필요 없는 경우에도 메모리 공간에서 제거되지 않고 공간을 차지하는 경우이다.

```js
const arr = [];
for (let i = 5; i > 1; i++) {
	arr.push(i - 1);
}
```

위 코드를 보면 알 수 있듯, 무한 루프를 도는 중 arr을 계속 참조하고 있기 때문에 GC는 이 항목에 대한 Sweeping을 수행하지 못하게 되고 결국 메모리 누수로 이어지는 결과를 낳게 된다.

이런 경우가 크게 3가지 패턴이 있다.

1. 전역 스코프에서 전역 변수를 많이 만드는 경우

2. EventListener 사용 후 removeListener 하지 않는 경우  
   _(계속 EventListener를 추가하게 된다.)_

3. setInterval()

<br>
<br>

### Single Thread

`Javascript는 Single Thread Language`

Javascript는 한 개의 Call Stack을 갖는다. 그러므로 추가적인 작업이 입력되었을 때, 현재의 Stack에 쌓이게 된다.

이와같이 Javascript는 synchronous한 특성을 갖게 되는데 여기서 무조건 의문점이 생길 수 밖에 없다.

'동기적인 작업이라면 비동기적으로 작업을 못하는 것 아닌가?'

그리고 실제로도 이 때문에 문제가 발생하는데, 여러 작업을 순차적으로 수행하면서 특정 작업이 아~주 오래 걸리게 된다면 나머지 작업들은 처리되지 못한 상태로 있게 될 것이고 사용자에게 매~우 나쁜 경험을 제공하게 될 것이다.

하지만 실제로 Javascript는 그런 모습을 보여주지 않고 있다.

바로 Javascript의 엔진 뿐 아니라 `Javascript Runtime`라는 더 큰 범위의 동작 원리가 존재하기 때문이다.

<br>
<br>

### Javascript Runtime

**Web API**

모든 브라우저는 Javascript Runtime을 내장하고 있다. Web API 또한 그 내장된 기능중 하나.

Web API는 HTTP 요청을 보내거나 DOM 이벤트를 듣거나 실행을 연기하는 등의 작업을 수행한다.

크롬 브라우저의 콘솔에 'window'를 입력하면 브라우저에 내장된 Javascript 객체가 나오게 된다. 바로 이 것이 Web API.  
_(착각해선 안되는 것이 Web API는 브라우저에 내장되어 있다는 것이다. Javascript 언어에 내장된 것이 아니라.)_

따라서 Web API를 이용해 백그라운드에서 비동기적 작업을 처리할 수 있고 작업을 마치면 Call Stack에 알림을 주어 다음 절차를 진행하게 만들 수 있다.

<br>

**Event Loop & Callback Queue**

Call Stack에 Web API를 활용한 작업이 들어오게 되면 Call Stack은 해당 작업을 Web API의 영역으로 인지하여 작업을 전달한다. 그리고 Web API는 작업을 처리하여 Callback Queue로 전달한다.

여기서 Event Loop이라는 존재는 Call Stack과 Callback Queue를 지속적으로 모니터링하며 Call Stack이 비어 있을 때, Callback Queue의 작업들을 순차적으로 전달하는 일을 수행한다.  
설령 Web API가 빠르게 작업을 마쳐도 Call Stack이 비어있지 않다면 작업을 전달하지 않는다.

<br>

**비동기 함수 실행 과정**

1. 콜 스택에서 비동기 함수가 실행되면 JS엔진은 브라우저에서 제공되는 웹 api에 작업을 위임한다.

2. 웹 api는 해당 비동기 작업을 수행한 후, 콜백 함수를 이벤트 루프를 통해 콜백 큐로 넘긴다.

3. 이벤트 루프는 콜 스택이 비어있을 때, 콜백 큐의 콜백 함수를 콜 스택으로 넘긴다.

4. 콜백 함수가 실행되며 콜 스택에서 제거된다.

<br>

싱글 스레드 언어임에도 블로킹이 일어나지 않고 여러 일을 동시에 처리하는 것처럼 동작하는데 이것을 concurrency라 부른다.

그 덕에 자바스크립트는 싱글 스레드 기반의 스크립트 언어임에도 비동기적 처리를 지원하기에 빠른 동작을 할 수 있는 것이돠.

<br>
<br>

### Nodejs

> 이 문서는 런타임에 대해 대략적으로 설명한 문서이기에 Nodejs를 자세하게 파진 않을 것이다.

브라우저는 클라이언트 딴이고 그 딴에서 어떻게 Javascript의 비동기적 처리가 이뤄지는지 봤다. 이젠 또 다른 JS Runtime인 Nodejs를 볼 차례(Nodejs는 서버사이드 플랫폼이라고 이해하면 된다).  
쉽게 생각해서 브라우저가 알아서 잘 깔끔하게 해주던 작업들을 따로 떼와서 만든 런타임~ 이라고 이해하면 된다.

Nodejs는 크롬의 V8엔진을 채택하고 `LIBUV`를 통해 비동기적 작업을 수행한다. 브라우저에서 떼왔다는 컨셉에 맞게 브라우저와 기본적인 유사성은 있지만 사실 따지고 보면 Nodejs는 브라우저보다 더 많은 일을 수행할 수 있다.  
ex) 파일 시스템 접근 등의 작업들...

_브라우저는 브라우저 외부, 즉, 컴퓨터 자체에 접근해서 무언가를 수행할 수 없다._

다만 브라우저에 내장된 Web API는 Nodejs에 없기에 window 객체는 없다. 대신 global API라는 것이 존재하고 이 것을 통해 비동기적인 작업을 수행한다.

<br>

**Nodejs Server**

Nodejs 서버를 운용하는 것은 기존의 서버 운용 방식과 다른 점이 있다.

기존의 서버 운용은 여러 요청에 대한 쓰레드가 각각 생성되어 그 많은 요청에 대해 Thread-pool이 관리한다. 그리고 Thread-pool은 먼저 도착한 요청이 수행되기전까지 다른 작업을 수행할 수 없었다.

하지만 Nodejs는 Single Thread로 구성되었고 HTTP 요청이 들어오면 바로 LIBUV 비동기 런타임으로 작업을 전달한다는 정도는 알고있으면 좋다!

<br>
<br>

### 결론!

자바스크립트의 엔진은 하나의 콜 스택을 가지는 싱글 스레드이다. 하지만 실제 작동은 브라우저나 node.js와 같은 멀티 스레드 환경에서 이뤄지기 때문에 자바스크립트와 웹api, 이벤트 루프 등을 분리하여 말하기엔 무리가 있다.

한마디로! 자바스크립트는 싱글 스레드로 동작하지만, 런타임 환경이 멀티 스레드를 제공하기에 멀티 스레드 프로세스 작업을 다룰 수 있다.

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

참고

https://soldonii.tistory.com/53

https://beomy.github.io/tech/javascript/javascript-runtime/
