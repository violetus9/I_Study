## Scope

<br>

컴퓨터 시스템의 여타 다른 자원들처럼 Javascript의 자원들 또한 라이프 사이클을 갖는다.(변수, 값, 함수같은 것들)

라이프 사이클이란 것은 생성부터 소멸까지를 이르는 말로, 컴퓨터의 자원은 유한하기에 각각이 라이프 사이클을 갖는 것이 중요하다.

JS에서 자원이란 값을 의미하며(문이 아님) 모두 라이프 사이클을 갖고 있다.

그리고 이 값이 저장되는 공간을 Scope라고 칭한다.(값의 활동 범위 정도로 이해하면 된다.)

<br>
<br>

### Scope

JS에서 스코프란 세가지를 의미한다.

- 전역 스코프
- 함수 스코프
- 블럭 스코프 (ES6+)

<br>

**전역 스코프**

전역 스코프는 말 그대로 전체적인 범주의 활동 범위이다. 전체적인 범위인만큼 프로그램의 생애와 함께한다.

브라우저가 HTML을 로딩하고, 페이지를 벗어나 새로고침 하기까지의 주기를 함께한다는 말이다.

당연하지만 전체적인 활동 범위이므로 그 안에 포함되는 다른 모든 지역 스코프에서 전역의 값을 참조할 수 있다. 전역 스코프는 임의로 생성하거나 삭제할 수 없다.

<br>

**지역 스코프**

지역 스코프는 전역 스코프에 포함될 수 밖에 없는 스코프이다.

지역 스코프는 두 가지로 나뉘는데

- 함수 스코프
- 블록 스코프

이도 마찬가지로 이름 붙여진대로 해석하면 된다.

함수 스코프는 함수의 호출과 함께 발동하며 함수 내부의 활동 범위를 만들고 그 안에서 활동하던 모든 값들은 함수의 종료와 함께 생을 마감한다...

블록 스코프도 마찬가지로 코드 블록의 생애와 함께 한다.

하지만 블록 스코프는 좀 더 공부가 필요하다. 바로 `var`라고 하는 구시대의 유물 때문이다.

<br>
<br>

### var, let, const

var, let, const는 모두 변수의 선언과 관련된 키워드들이다.

var을 제외한 모두는 ES6에서 추가된 문법사항이며 var는 함수 스코프, 나머진 블록 스코프를 갖는다.

이 문서에서는 키워드들의 모든 차이를 보진 않을 것이고 스코프에 영향을 받는 차이점만 볼 것이다.

<br>
<br>

### 호이스팅 & TDZ

**호이스팅**

호이스팅은 `끌어올린다`라는 개념으로 JS에서 사용하는 여러 선언 키워드들에서 보여지는 특징인데, 다른 키워드와 달리 `var`는 호이스팅과 동시에 초기화가 되지 않으면 자동으로 undefined를 할당하여 메모리를 차지한다.

```js
console.log(x); // undefined

var x;

console.log(y); // ReferenceError: Cannot access 'y' before initialization

let y;

z = "okdk";

console.log(z); // "okdk"
```

_선언보다 먼저 초기화를 진행시켜버린 모습, var 이외의 다른 선언문은 오류를 발생시킨다._

_이 예시는 물론 전역스코프에서 실행했지만, 전역 스코프가 아닌 각각의 스코프에서도 매커니즘은 동일하다._

_그리고 z 같은 경우 var를 선언하지 않아도 자동으로 var 넣어준 모습_

<br>

종합선물세트

```js
var x = "this is x";

(function () {
	console.log(`1. ${x}`);
	var x = "actually not";
})();
console.log(`2. ${x}`);

y = "???";
console.log(`3. ${y}`);

z = "zzz";
console.log(`4. ${z}`);
let z;
```

직접 실행해보면 var가 왜 함수 스코프인지, 호이스팅이 무엇인지 감을 잡을 수 있을 것임.

그리고 나아가서 ES6에서 let, const가 나올 수 밖에 없었는지도 알 수 있다.

<br>
<br>

**TDZ**

Temporal Dead Zone.

`let`, `const`는 TDZ의 제한을 받는다.

앞서 봤듯이 var처럼 undefined를 반환하지 않고 참조 에러를 반환한다. var와는 달리 맺고 끊음이 확실한 것이다.

```js
console.log(x); // ReferenceError: Cannot access 'x' before initialization
/* TDZ인 영역 */
let x;

console.log(x); // undefined
```

_let에서도 호이스팅이 일어난다는 증거, 다만 TDZ란 존재 때문에 초기화 이전에 접근하게 되면 에러를 발생시킨다._

<br>

**TDZ 자세히 알아보기**

let과 const 선언은 실행 컨텍스트의 `Lexical Environment`로 지정된 변수를 정의한다.

렉시컬 환경에 포함되는 순간 생성되지만 실행 전까진 접근할 수 없다.

새로운 스코프에 진입할 때마다 지정 스코프에 포함된 모든 let, const 바인딩이 해당 스코프 내부의 코드가 실행되기 전에 실행된다.(호이스팅 된다는 것)

let, const의 변수는 초기화 구문이 완전 실행된 이후 우변을 실행하고, 그 결과가 선언된 변수로 할당되며 초기화된다.

```js
let x; // undefined
// const는 어차피 선언과 동시에 값을 할당해야 하니까 적지 않음.
```

정리하자면, TDZ는 초기화 되지 않은 바인딩에 접근을 시도할 때 에러를 제공하기 때문에 개발자에게 편리함을 제공한다.

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

참고

https://medium.com/korbit-engineering/let%EA%B3%BC-const%EB%8A%94-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85-%EB%90%A0%EA%B9%8C-72fcf2fac365
