## Oauth2

"인증을 위한 스탠다드 인터넷 프로토콜."

<br>

### 최근의 인터넷 생테계

최근 인터넷은 SaaS(Software as a Service)의 형태를 띈다. 사용자가 필요한 부분만 서비스를 받을 수 있다는 것. 실제로 서비스를 사용하다보면 kakao나 naver, google에서 만든 서비스가 아님에도 해당 플랫폼들의 로그인을 통해 이용할 수 있다. 외부 서비스에서 해당 플랫폼의 인가를 받아 외부 서비스를 이용할 수 있게 한다는 것.

이 방식은 사용자에게 불필요한 절차를 거치지 않게 하며, 계정의 통일된 관리가 가능해지고 여러 인터넷 서비스 업체들에게도 사용자를 좀 더 유치할 수 있게하는 편의성을 제공한다.

<br>

### Oauth2

**_Oauth2는 Oauth1.0과 호환되지 않지만(완전 다른 개념이라고 봐도 무방) 인증 절차가 간략해진 개선판_**

`사용자가 어플리케이션을 이용함에 모든 권한을 넘기지 않고 서비스를 이용할 수 있게 하는 HTTP기반 보안 프로토콜.`

Oauth는 Authentication(인증), Authorization(허가) 2가지 의미를 내포하는데, 서비스 이용 전 사용자로 하여금 동의를 구하는 절차를 진행하는 경우를 많이 봤을 것이다.  
이는 3자로부터 접근 권한을 부여받는 단계로 이어져 원활한 서비스 이용을 가능케 해준다.

Oauth 방식은 여러 장점이 있지만 가장 먼저 떠오르는 장점은 사용자가 민감 정보를 다루는데 있어 하나의 계정으로 관리할 수 있게 한다는 것.

<br>

### 개념

**역할군**

1. 자원 소유자 (Resource Owner)

- 정보의 소유권을 가진 사용자

2. 자원 서버 (Resource Server)

- 자원 소유자의 정보를 보관하는 서버(google, naver, kakao, ...)

3. 인가 서버 (Authorization Server)

- 자원 소유자를 인증하며 클라이언트에게 Access Token을 발행

4. 클라이언트

- 제 3자 어플리케이션, 사용자의 동의를 구해 자원 서버로 정보를 요청할 수 있다

**_자원 서버와 인가 서버를 구축한 대상을 Provider라고 한다._**

<br>

**토큰**

인가 서버로부터 발급된 랜덤 문자열. 두 가지 종류가 있다.

1. Access Token

- 클라이언트가 자원 서버로 요청하기 위한 허가용 토큰

- 각 Provider마다 만료기간이 있다. 당연하게도 만료되면 사용 불가.

2. Refresh Token

- Access Token이 만료되면 새 Access Token을 발급 받기 위해 필요한 토큰

- 마찬가지로 만료기간이 있다. Provider마다 다르며 Access Token보다는 기간이 길게 설정되어 있다.

<br>

### 절차

**클라이언트 등록**

자원 서버에서 데이터를 가져오기 위해선 인가 서버의 클라이언트로 등록해야 한다.

각 Provider는 각자의 로직으로 이를 허용할 수 있다. 프로토콜은 클라이언트가 지정해야하는 매개변수와 인가 서버에서 반환해야 하는 매개변수만 정의한다.

- 매개 변수

  - 앱 이름
  - Redirection URL: 인증 코드, Access Token을 받기 위한 클라이언트 URL
  - 권한 부여 유형
  - Javascript Origin(Optional): XHR을 통해 자원 서버를 요청할 수 있는 호스트 이름

- 인가 서버 응답

  - 클라이언트 ID: 고유 임의 문자열
  - 클라이언트 Secret: 반드시 비밀로 해야하는 비밀 키(노출 절대금지)

<br>

**인가 유형**

Oauth2는 Access Token을 얻는 데 관련한 클라이언트 위치나 특성에 맞게 4가지 유형을 정의한다.

<br>

- **Authorization Code Grant Type**

  클라이언트가 웹 서버인 즉시 사용해야 한다. 갱신 토큰으로 갱신할 수 있기 때문에 장기적 Access Token을 얻어낼 수 있다.(인증 서버 활성화된 경우)

  ```
  시나리오

  자원 소유자: A
  자원 서버: kakao 서버
  클라이언트: 모든 웹사이트
  인가 서버: kakao 서버

  1. 웹 사이트에서 A의 kakao 프로필 정보를 얻고 싶다.
  2. 클라이언트에 의해 kakao 서버로 Redirection 된다.
  3. 접근 권한을 부여하면 인가 서버(kakao 서버)는 콜백 응답을 통해 인증 코드를 클라이언트로 보낸다.
  4. 해당 코드는 클라이언트와 인가 서버 간의 Access Token과 교환
  5. 얻어낸 Access Token을 통해 자원 서버를 통해 프로필 데이터 검색 가능
  ```

  Access Token은 웹 브라우저에 저장된다.(session, ...) 추가적으로 토큰 수명이나 새로고침 토큰과 같은 기타 정보를 함께 보낸다.

  해당 방법은 Access Token이 클라이언트(여기선 브라우저)에서 전달되지 않기에 안전하다고 할 수 있는 방법

<br>

- **Implicit Grant Type**

  클라이언트가 Javascript와 같은 스크립팅 언어를 사용하는 브라우저에서 실행될 때 사용된다. 이 유형은 갱신 토큰 발행을 허용치 않는다.

  ```
  시나리오

  자원 소유자: A
  자원 서버: kakao 서버
  클라이언트: ReactJS 쓰는 웹사이트
  인가 서버: kakao 서버

  1. 웹사이트에서 A의 kakao 프로필 정보를 얻고 싶다.
  2. 클라이언트에 의해 인가 서버로 Redirection.
  3. 접근 권한을 부여하면 인가 서버는 URI에 Access Token을 사용하여 클라이언트로 Redirection(웹 서버로 전송되진 않음)
    (콜백 예시: http://example.com/oauthcallback#access_token=MzJmNDc3M2VjMmQzN.)
  4. Access Token은 클라이언트에서 자원 서버를 쿼리하더나 검색하는데 사용이 가능하다.
    (쿼리 예시: https://graph.kakao.com/me?access_token=MzJmNDc3M2VjMmQzN.)
  ```

  해당 과정에서 클라이언트는 CORS로 인해 차단되지 않고 Javascript로 kakao API를 호출할 수 있냐면,

  해당 요청의 응답으로 Access-Control-Allow-Origin이란 헤더를 kakao가 승인하기 때문이다.

  _이 유형은 다른 유형의 승인 과정을 사용할 수 없을 때만 사용토록 한다. Access Token이 클라이언트에서 노출되기 때문._

<br>

- **Resource Owner Password Credentials Grant Type**

  이 유형은 자격을 증명할 수 있는 정보가 클라이언트로 전송된 후 인가 서버로 전송된다. 이렇게 할 수 있는 이유는 클라이언트와 인가 서버의 관계가 신뢰 관계이기 때문이다. 클라이언트가 인가 서버와 동등한 권한을 가졌을 때 주로 사용된다.

  ```
  시나리오
  - 해당 유형은 example.com 이란 부모 웹사이트가 자체 서비스인 api.example.com의 보호된 자원에 접근하려고 하는 경우를 들 수 있다.
    이 둘은 계정 자체가 부모 서비스에서 생성되었기 때문에 인증 절차에 대해 충분히 신뢰할 수 있다는 것.

  자원 소유자: A사의 웹사이트 A에 계정이 있음
  자원 서버: api.A서 api를 제공하고 있는 A사
  클라이언트: A사의 웹사이트 A
  인가 서버: A사의 서버

  1. A사는 타사 어플리케이션에서 RESTful API를 사용할 수 있게끔 한다.
  2. 아무래도 새로운 개발을 추진하기보단 자사 API를 사용하는 편이 좋겠다.
  3. 자체 API 메서드 호출을 위한 Access Token이 필요하다.
  4. 표준 HTML 양식을 통한 로그인 자격 증명을 입력토록 요청한다.
  5. 서버측 어플리케이션 (웹사이트 A)은 인가 서버의 Access Token과 클라이언트의 (자격을 증명할 수 있다면) 허가를 교환한다.
  6. 해당 어플리케이션은 Access Token을 통해 자체 자원 서버 api.A를 쿼리할 수 있다.
  ```

  <br>

- **Client Credentials Grant Type**

  클라이언트가 자원 소유자인 경우 사용된다. 최종적으로 사용자로부터 얻을 수 있는 권한이 없다.

  ```
  시나리오

  자원 소유자: 모든 웹사이트
  자원 서버: 어딘가의 Cloud Storage B
  클라이언트: 자원 소유자
  인가 서버: B의 서버

  1. 웹사이트는 모든 종류의 파일을 B에 저장한다.
  2. 웹사이트는 B의 API를 통해 파일을 검색하거나 수정해야 하고 인가 서버에 인증해야 한다.
  3. 인증되면 웹사이트는 자원 서버를 쿼리하는데 사용할 수 있는 Access Token을 취득한다.
  ```

  여기선 최종적으로 사용자는 자원 서버에 접근하기 위해 권한을 부여할 필요가 없다.

<br>
<br>

**Oauth2가 보안에 취약하다는 경우가 더러 있지만, 그런 경우는 보통 개발자의 잘못된 로직이나 실수가 초래하는 경우라고 한다. 그러므로 프로토콜을 구현할 때 정확히 어느 부분에서 취약함이 생겨날 수 있는지 파악할 수 있는 안목을 기르자**

(취약점에 대한 시나리오는 아래 참고 링크에서 `here`링크를 참고하자)

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

참고

https://d2.naver.com/helloworld/24942

https://devhaks.github.io/2019/05/31/oauth2/

`here`
http://www.bubblecode.net/en/2016/01/22/understanding-oauth2/

https://oauth.net/2/
