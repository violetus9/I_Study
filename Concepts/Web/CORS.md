## CORS

Cross-Origin Resource Sharing.

CORS는 추가 HTTP 헤더를 사용, 한 출처에서 실행 중인 웹 어플리케이션이 다른 출처의 선택된 자원에 접근할 수 있는 권한을 부여토록 브라우저에 알려주는 체제이다.  
웹 어플리케이션은 리소스가 자신의 출처(domain, protocol, port)와 다를 때 교차 출처 HTTP 요청을 실행한다.

_ex) https://domain-a.com의 프론트 엔드 JS코드가 XHR를 사용, https://domain-b.com/data.json을 요청하는 경우_

<br>

보안 상의 이유로 브라우저는 스크립트에서 시작한 교차 출처 HTTP 요청을 제한하게 된다. XHR, Fetch API는 CORS 정책을 따르는데 이 API들을 사용하는 웹 어플리케이션은 자신의 출처와 동일한 리소스만 불러올 수 있다는 이야기.

만약 다른 출처의 리소스를 불러오길 원한다면 해당 출처에서 올바른 CORS 헤더를 포함한 응답을 반환해야 한다.

<br>

### 출처(Origin)가 뭔데

웹 주소창은 여러 구성 요소로 이루어져 있다.

`https://www.google.com/search?q=cors&rlz=1C1CAFC_enKR813KR813&oq=CORS&aqs=chrome.0.69i59j0i20i263i512j0i433i512j0i512l2j69i60l3.2728j0j4&sourceid=chrome&ie=UTF-8`

를 보면 구성이 다음처럼 나뉜다는 것을 알 수 있다.

Protocol: `https://`  
Host: `www.google.com`  
Path: `/search`  
Query String: `?q=cors&이하 뒤 구문들`  
Fragmant: `#~~~해서 #뒤에 오는 내용들`(위 예시엔 없지만..)

즉, 서버의 위치를 찾아가기 위한 가장 기본이 되는 요소를 합쳐놓은 것이다.

또한 출처 내의 포트 번호는 생략이 가능하다. 이유는 각 웹에서 사용하는 HTTP, HTTPS 프로토콜의 기본 포트가 정해져 있기 때문이다. (그렇기 때문에 위 예시에서도 HTTPS의 포트인 :443이 생략됨)

추가적으로 `Location` 객체가 가진 `origin` 속성에 접근하여 출처를 알아낼 수도 있다.

```js
// 요렇게
console.log(location.origin);
```

<br>

### SOP

Same-Origin Policy.

같은 출처에서만 리소스를 공유할 수 있다~ 라는 규칙을 가진 정책이다.

하지만 실제론 여러 웹 환경에선 동일 출처만을 고집할 수는 없는 것. 그렇기 때문에 예외 조항으로 CORS 정책을 포함한다.

> Network resources can also opt into letting other origins read their information, for example, using Cross-Origin Resource Sharing.
>
> > RFC 6454 - 3.4.2 Network Access

그러니까 다른 출처를 통해 리소스를 요청하면 SOP 정책에 위반되는 것이고 거기에 더해 CORS 정책마저 지키지 않았다면 다른 출처의 리소스에 대한 접근이 불가능하다.

뭐가 이렇게 왜때문에 복잡한건지 참;

근디 잘 생각해보면 왜 그렇게 해놨는지 알 수 있다.

만일 이런 정책이 없다면 브라우저의 웹 환경은 보안에 매우 취약한 상태가 된다. 당장 개발자 도구만 열어봐도 알 수 있는 정보들(DOM 구조나 어느 서버와 통신하는지와 리소스 출처나~ 이런 것들)이 수두룩하기 때문이다.

물론 이런 부분을 조금이나마 해소하려고 JS코드의 난독화라던가 하는 개념들이 등장했지만 어디까지나 난독이라는 것은 어렵다는 얘기지 불가능하다는 얘기가 아니니까..

_심지어 어떤 사이트는 난독화마저 안되어서 script 내용이 모두 노출됨_

그런 취약점 때문에 CSRF(Cross-Site Request Forgery), XSS(Cross-Site Scripting)과 같은 방법은 마치 우리의 어플리케이션에서 코드가 실행된 것 처럼 꾸며 정보를 탈취해 갈 수도 있다.

<br>

### 그렇다면 출처의 구분은 어떻게 이뤄질까

`Scheme`, `Host`, `Port`만 같으면 된다.

앞서 설명했던 개념에 `Scheme`이란 것이 추가됐는데 그냥 쉽게 말하면 Scheme란 것은 `https://` 부분이 같은지 보면 된다~

그리고 앞서 `Port`는 생략 가능하다고 했었는데 이 경우는 어떻게 판단하냐? 라고 한다면, 이 경우는 서버의 로직에 따르지 않고 브라우저 자체적으로 구현된 스펙이기에 브라우저가 알아서 처리한다.  
_근데 정신나간 IE는 포트번호를 무시한다.._

그러니까 CORS는 브라우저의 구현 스펙에 포함되는 정책이기 때문에 브라우저를 통하지 않는 서버간 통신엔 CORS 정책이 적용되지 않는다.

<br>

## CORS의 동작 방법

서로 다른 출처의 리소스를 어떻게 안전하게 쓸 수 있을까?

기본적으로 웹 클라이언트 어플리케이션은 다른 출처의 리소스를 요청할 때 HTTP 프로토콜을 사용하여 요청을 보낸다. 이 때 브라우저는 Origin이란 필드에 요청을 보내는 출처를 함께 담아 보낸다.

이후 서버는 이 요청에 대한 응답시 `Access-Control-Allow-Origin`이란 값에  
"우리 리소스에 접근이 허용된 출처입니다"  
라고 응답하고, 이 응답을 받은 브라우저는 자신이 보냈던 요청과 서버의 응답을 비교하여 유효성을 판단한다.

쉽게 말해서 이렇지 실상은 조금 더 복잡하다. 세가지의 경우에 따라 시나리오가 변경되기 때문이다. 그렇기 때문에 우리가 보낸 요청이 어느 경우인지를 파악할 능력이 된다면 추후 CORS 정책 위반 시 에러를 고치는데 시간을 덜 써도 될 것이다.

<br>

### 그럼 세가지 경우가 뭔지 한번 봐야겠지

1. **Preflight Request**

   일반적으로 웹 어플리케이션 개발 시 가장 많이 마주치게 되는 시나리오로, 브라우저는 요청을 한번에 보내지 않고 예비 요청과 본 요청으로 나누어 서버로 전송하는 방식이다.

   이 경우 예비 요청이 `Preflight`가 되는 것이다. 이 요청에는 HTTP 메서드 중 `OPTIONS` 메서드가 사용된다. 요청을 보내기 전 브라우저 스스로 이 요청에대한 안전성을 판별하는 과정이라고 보면 된다.

   | Javascript   | Browser                       | Server              |
   | ------------ | ----------------------------- | ------------------- |
   | fetch()      |                               |                     |
   |              | OPTIONS /resources(예비 요청) |                     |
   |              |                               | 200 Ok, A-C-A-O: \* |
   |              | GET /resources (본 요청)      |                     |
   |              |                               | 200 Ok              |
   | Promise.then |                               |                     |

   _대강 요런 식으로 진행, ACAO가 `*`로 설정된건 모든 출처를 허용한다는 것._

   fetch API를 통해 브라우저에 리소스 명령을 보내면 브라우저는 서버로 예비 요청을 보내고, 그 요청의 응답으로 서버는 대강 자신이 이 요청에 대해 어느 것을 허용하며 금지할 것인지 응답 헤더에 담아 전송한다.

   이후 브라우저는 자신이 보낸 요청과 들어온 응답에 대한 비교를 거쳐 다시 본 요청을 보내고, 서버는 다시한번 안전성을 판단한 후 본 응답을 보낸다.

   <br>

   이 때, CORS 정책 위반으로 인한 에러는 예비 요청의 성공 여부와 관련이 없다. 브라우저가 CORS 정책 위반 여부를 판단하는 시점은 예비 요청에 대한 응답을 받은 이후가 되기 때문이다.

   예비 요청 자체가 실패해도 CORS 위반으로 분류 되지만, 중요한 부분은 요청에 대한 실패와 성공 여부가 아닌 응답 헤더에 유효한 Access-Control-Allow-Origin 값이 존재하는지 여부이다.

   설령 예비 요청이 실패하여 200이 아닌 다른 상태코드를 전달 받더라도 헤더에 ACAO 값이 잘 들어있다면 CORS 정책 위반이 아니라는 것이다.

<br>

2. **Simple Request**

   전체적인 과정은 `Preflight`와 크게 다르지 않다. 다만 이 시나리오의 경우 전달 받은 ACAO 값에 대해 브라우저가 CORS 정책 위반 여부를 판별하는 방식이다.

   | Javascript   | Browser                  | Server |
   | ------------ | ------------------------ | ------ |
   | fetch()      |                          |        |
   |              | GET /resources (본 요청) |        |
   |              |                          | 200 Ok |
   | Promise.then |                          |        |

   _예비 요청 없이 바로 본론으로 들어가는 모습_

   허나 아무때나 이렇게 단순 요청을 보낼 수 있지는 않다. 해당하는 경우에만 예비 요청을 생략할 수 있다. 그리고 해당하는 조건이라는게 "일반적인 웹 어플리케이션 아키텍쳐"를 설계하게 되면 충족시키기 매우 어려운 조건들이란다.

   ```
   1. 요청의 메서드는 GET, HEAD, POST 중 하나여야 한다.

   2. Accept, Accept-Language, Content-Language, Content-Type, DPR, Downlink, Save-Data, Viewport-Width, Width를 제외한 헤더를 사용하면 안된다.

   3. 만약 Content-Type를 사용하는 경우에는 application/x-www-form-urlencoded, multipart/form-data, text/plain만 허용된다.
   ```

   왜 충족하기 어렵다고 했는지 확 이해가 됐을 것이다.

   더욱이 2번 조건의 헤더들은 매우 기본적인 헤더들이기도 하고, 대부분의 HTTP API는 `text/xml`이나 `application/json` 컨텐츠 타입을 가지도록 설계되기 때문에 현실적으로 조건을 충족하기 어렵다고 했던 것.

<br>

3. **Credentialed Request**

   인증된 요청을 사용하는 방법이다. 일반적인 방법이라기보단 다른 출처간 통신에 좀 더 보안성을 강화하고자 할 때 사용한다.

   일반적인 경우 `XHR` 객체나 `fetch API`는 별다른 옵션 없이 브라우저의 쿠키, 인증 관련 헤더를 요청에 맘대로 포함하지 않는다. 이 경우 추가적인 정보를 담게 해주는 옵션은 `credentials` 이다.

   해당 옵션엔 총 3가지 값을 사용할 수 있다.

   ```
   same-origin (default): 같은 출처 간 요청에만 인증 정보를 담을 수 있다.

   include: 모든 요청에 인증 정보를 담을 수 있다.

   omit: 모든 요청에 인증 정보를 담지 않는다.
   ```

    <br>

   _대강 이렇게 사용함_

   ```js
   fetch("https://somewhere.com/testtext.xml", {
   	credentials: "include",
   });
   ```

   만약 우리가 위의 옵션을 사용한다면 브라우저는 리소스 요청에 있어 ACAO뿐만 아니라 좀 더 디테일한 검사 조건을 추가한다.

   예를 들어보자

   앞선 시나리오에서 ACAO:\* 라고 모든 리소스를 허용한 경우  
    "모든 요청이 안전하다"라고 판단했다.

   하지만 `credentials` 옵션의 `include`를 적용했다면, 무조건 요청에 인증 정보가 포함되도록 설정한 것이 된다. 그 결과 브라우저의 쿠키 정보가 함께 담겨 있게 되지만, 모든 요청을 허용하겠다는 `*`를 ACAO 헤더에 사용하지 말라고 한다.

   즉, 요청에 인증 정보가 담긴 상태에서 타 출처의 리소스를 요청하면 브라우저는 CORS 정책 위반을 판별함에 다음의 규칙을 추가한다.

   ```
   1. ACAO엔 *를 사용할 수 없다. 명시적인 URL을 써라.

   2. 응답 헤더엔 반드시 Access-Control-Allow-Credentials: true가 존재해야한다.
   ```

   <br>

   이번 시나리오는 다른 시나리오와 비교했을때 좀 까다롭지만 잘 습득해두면 추후 있을 CORS 에러에 대해 숙련된 대처를 할 수 있을 것임!

<br>

## CORS 해결 방법을 알아보자

- **Access-Control-Allow-Origin 세팅**

  가장 일반적인 해결 방법이다. 걍 ACAO 헤더에 알맞게 값을 세팅하면 되는 것.

  하지만 `*`을 사용하면 당장은 편할지 몰라도 보안적으로 이슈가 생길 수도 있음을 염두해두자.

  그러니까 `Access-Control-Allow-Origin: http://어딘가의web.com`처럼 출처를 명시해버릇 하자.

  또한

  이 헤더는 Nginx, Apache와 같은 서버 엔진 설정에서 추가할 수 있지만 복잡하므로 웬만하면 소스 코드 내에서 응답 미들웨어 등을 사용하여 세팅하도록 하자. Express, Spring 같은 유명한 백엔드 프레임워크는 CORS 관련 설정을 제공하니까 편할 것임.

  <br>

- **webpack-dev-server를 통한 리버스 프록싱**

  CORS 자체는 프론트 엔드 개발 시 많이 접할 것이다. 서버딴은 이미 ACAO 헤더가 세팅되었지만, 백엔드에서 범용적인 출처를 명시하는 경우가 거의 없으니까.

  그러니까 프론트 엔드 개발 시 webpack-dev-server를 사용하여 개발 환경 구축시 해당 라이브러리가 제공하는 proxy 기능을 사용하여 CORS 정책을 우회할 수 있다.

  ```js
  module.exports = {
  	devServer: {
  		proxy: {
  			"/api": {
  				target: "http://어딘zfzsd가af.com",
  				changeOrigin: true,
  				pathRewrite: { "^/api": "" },
  			},
  		},
  	},
  };
  ```

  위 설정대로면 로컬 환경서 `/api`로 시작하는 URL 요청에 대해 브라우저는 `localhost:port/api`로 요청을 보낸 것으로 간주하지만, 웹팩이 `target`으로 요청을 프록싱하기에 CORS를 잘 지킨 것 처럼 원하는 서버와 원활한 통신이 가능하다.

  하지만 어디까지나 로컬 개발 환경에서 그렇다는 것이지 어플리케이션을 빌드하여 서버로 올리면 더이상 작동하지 않을 것이다.

  <br>
  <br>

**CORS는 브라우저의 구현 정책이라고 했다. 따라서 프론트 엔드라면 자주 접하게 되는 부분이다...물론 우회하는 방법이 있지만 근본적인 문제로는 아이러니하게도 백엔드 개발자가 올바른 ACAO 값이 응답될 수 있도록 세팅해야 한다. 즉, 운영 환경에서 CORS 문제를 해결하기 위해선 백엔드 개발자와 적극적으로 소통해서 고쳐나가도록 하자~**

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

참고

https://developer.mozilla.org/ko/docs/Web/HTTP/CORS

https://evan-moon.github.io/2020/05/21/about-cors/
