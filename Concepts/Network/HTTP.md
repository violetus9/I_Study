## HTTP

HyperText Transfer Protocol

웹 브라우저는 다음과 같은 요청 흐름을 갖는다.

1. 웹 브라우저가 HTTP 메시지 생성
2. SOCKET 라이브러리를 통해 전달
   a. TCP/IP 연결 (IP, PORT)
   b. 데이터 전달
3. TCP/IP 패킷 생성, HTTP 메시지 포함
4. 기타 LAN 드라이버, LAN 장비를 통한 통신

사실상 요즘 브라우저에선 HTTP 메시지에 모든 것을 전송한다고 보면 된다.  
 _HTML, TEXT, IMG, 음성, 영상, 파일, JSON, XML 등.._  
거의 모든 형태의 데이터를 전송 가능하며 서버간 데이터를 주고 받을 때에도 대부분 HTTP를 사용한다.

<br>

HTTP 특징은 대략 이렇다.

- 클라이언트-서버 구조
- 상태 없음(stateless), 비연결성
- HTTP 메시지
- 단순하며 확장성이 좋음

이제 이 내용들에 대해 자세히 알아보자

<br>
<br>

### HTTP 특징

<br>

**클라이언트-서버**

요청-응답 구조라고 생각하면 된다. 클라이언트는 서버에 요청을 보내며 응답을 기다린다. 응답이 도착하면 요청에 맞는 결과를 만들어 반환한다.

<br>

**stateful, stateless**

여기서 stateless라 함은 서버가 클라이언트의 상태를 보존하지 않는 것을 말한다. 이에 대한 장점은 서버의 확장성을 높일 수 있다는 장점이 있지만 클라이언트가 추가적으로 상태에 어울리는 데이터를 전송해야 한다는 단점이 있다.

그렇다면 stateful과 stateless의 차이는 뭐가 있을까?

stateful은 말 그대로 상태를 가지겠다는 이야기이다. 한 예로 손님이 점원에 요청을 보낸 경우(서버가 점원) 손님의 요청에대한 상태를 점원은 알고 있을것이며 그에 맞는 서비스를 제공할 것이다. 하지만 만약 매장이 매우 바빠 여러 손님의 요청을 받는 경우라면 점원이 화장실을 가거나 잠시 자리를 비운 경우 매장은 정지상태가 될 것이다. 여기서 stateless가 빛을 발한다. 손님은 쪽지 형식으로 주문사항을 적어놓고 점원들은 그에 맞는 응답을 주기만 하면 되기 때문이다. 더이상 점원이 모든 것을 기억 할 필요가 없는 것이다.  
그 덕에 매장측은 점원 수를 늘려 일처리를 빠르게 할 수도 있을 것이다(서버 증설)

모든 것이 완벽해 보이지만 stateless는 실무상 한계점이 분명 있다. 모든 상황을 상태를 가지지 않게끔 할 수는 없는 노릇이기 때문이다. 로그인처럼, 반드시 상태를 가져서 해당 유저만이 수행해야 하는 일들의 경우가 그렇다.

불가피하게 상태를 관리해야 한다면 상태 유지에 대한 비용은 최소화 하는 것이 좋다. 일반적으로 브라우저 쿠키, 서버 세션을 이용한 상태 유지를 사용한다.

서버 개발자의 입장에선 상태를 유지 하지 않는것이 매우 중요하다. 수강신청이나 정시 티켓팅같은 경우 순식같에 트래픽이 몰리기 때문이다.

<br>

**connectionless**

연결을 계속 유지한다면 비용이 계속 발생한다. 그렇기 때문에 요청과 응답이 이뤄진 후 바로 연결을 끊어 서버에 최소한의 자원을 사용하게 할 수 있다.

HTTP는 기본적으로 연결을 유지 않는 모델이다. 초 단위 이하의 빠른 속도로 응답을 할 수 있고 수천개의 서비스를 사용해도 실제로 서버상 동시 처리 요청은 수십개 이하로 매우 적다.  
(보통 검색 버튼을 미친듯이 투타ㅏ타탇ㄷ다가다 누르진 않으니까)

물론 TCP/IP 연결을 새로 맺어야 하며 브라우저로 요청 시 HTML을 비롯한 자원을 다시 다운로드 해야 하는 등의 단점이 있지만 점차 개선되고 있다고 한다. (요즘은 Persistent Connections란 방법을 쓴다고 함)

<br>

**HTTP 메시지**

요청 메시지와 응답 메시지로 나눌 수 있다.

- **요청**

  **Method**: GET, POST, OPTIONS, HEAD, 경우에 따라 다른 동작을 요구할 수도 있다.

  **Path**: 프로토콜, 도메인 또는 TCP 포트 요소들을 제거한 자원의 URL

  **HTTP protocols's version**

  **Headers**: 서버에 추가 정보를 전달하는 선택적 헤더

  **etc**: POST같은 몇 메서드를 위한 전송 자원을 포함하는 응답의 본문과 유사한 본문

  <br>

- **응답**

  **Http protocol's version**

  **Status code**: 요청 성공 여부, 그 이유를 나타내는 상태 코드

  **Status message**: 영향력을 갖지 않는 상태 코드의 짤막한 설명

  **Headers**: 요청 헤더와 비슷한 HTTP 헤더들

  **etc**: 선택 사항. 가져온 자원이 포함되는 본문

  <br>

  **HTTP 메시지 구조**

  | 요청 라인(메서드 URI HTTP ver.) | 상태 라인(HTTP ver. 응답 코드 상태 |
  | ------------------------------- | ---------------------------------- |
  | 헤더                            | 헤더                               |
  | 공백 라인                       | 공백 라인                          |
  | entity body(request)            | entity body(response)              |

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

참고

https://developer.mozilla.org/ko/docs/Web/HTTP/Overview

**HTTP header**  
https://developer.mozilla.org/ko/docs/Web/HTTP/Headers

http://www.cleantutorials.com/html/format-of-http-request-response-header-and-body-with-example
