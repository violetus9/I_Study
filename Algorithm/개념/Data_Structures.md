## 자료구조
* CPU : 영구 저장소
* RAM : 임시 저장소   

자료구조는 RAM을 사용한다.   
CPU에서 가져오는 것보다 월등히 빠르기 때문   
결국 Data처리를 **어떻게 효율적으로** 할까! 가 목적

<br>

----------------
<br>

## 배열
자료들이 메모리 주소에 순서대로 정렬되어 저장되어있음   
iterate 해야하는 경우 최적!

* push, pop 'O(1)'   
배열 끝 요소를 처리하기만 하면 됨
* shift, splice 'O(n)'   
배열 맨 앞 요소를 처리함에 나머지 요소의 인덱스 **재할당**

### **정리**
검색이 빠름,<br>
전체 자료를 검색하지 않는 선에서 처리가 빠름(like push,...)<br>
그러나 수정이 일어나는 부분에서 느려질 수 있음(배열을 순회하는 경우)<br>
JS는 동적인 배열, Java는 정적인 배열

<br>

--------------
<br>

## 해시 테이블
Key, Value 쌍으로 데이터가 저장됨   
키는 유니크, 키하나에 밸류하나 매핑   


* 해시 충돌   
서로 다른 키가 같은 해시를 가지면 발생
완벽한 조건을 만족시켜주는 해시함수를 구현하기 어렵(거의 불가능)당   
기본적으로 키 사이즈에 비해 hash map의 사이즈가 작아서 충돌이 날 수 밖에없다   

* 해결 방법
  * Separate chaning   
  : Linked list로 연결연결...
  * Open addressing   
  : 비어있는 공간 활용

### **정리**
검색, 삽입, 삭제, 조회 모두 빠름<br>
근데 주소 할당이 다소 무작위적임

<br>

----------------


<br><br><br><br><br>
-----------
