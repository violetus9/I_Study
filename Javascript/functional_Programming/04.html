<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>map, filter, reduce</title>
</head>

<body>

  <script>const log = console.log;</script>

  <script>
    const products = [
      { name: '반팔티', price: 15000 },
      { name: '긴팔티', price: 20000 },
      { name: '핸드폰케이스', price: 15000 },
      { name: '후드티', price: 30000 },
      { name: '바지', price: 25000 },
    ];
  </script>

  <!-- map -->
  <script>
    // f함수에게 위임을 한다.
    const map = (f, iter) => {   // 받을 인자가 iterable protocol을 따름
      let res = [];
      for (const a of iter) { // 어느 값이 올지 모르기에 a로 그냥 해준 것
        res.push(f(a));
      }
      return res; // 함수형 프로그래밍에서 함수는 인자와 리턴값으로 소통하길 권장한다.
    };              // 그렇게 리턴된 값으로 다른 곳으로 활용

    // 이 경우 사용하는 함수가 map(상단에 작성함)
    // let names = [];
    // for (const p of products){
    //   names.push(p.name);
    // }
    // log(names);

    let prices = [];
    for (const p of products) {
      prices.push(p.price);
    }
    log(prices);

    // 사용
    log(map(p => p.name, products));
    log(map(p => p.price, products));

    // map함수는 고차함수, 함수를 값으로 다루며 원하는 시점에 인자를 적용하는 함수이기도 함

  </script>

  <!-- 이터러블 프로토콜을 따른 map의 다형성 -->
  <script>

    // map함수는 iterable protocol을 따르기에 다형성이 매우 높다
    // log(document.querySelectorAll('*').map(el => el.nodeName)); // 오류 발생, 배열 처럼 생겼지만 아니다

    // 하지만 아래와 같이 실행하면 동작한다
    log(map(el => el.nodeName, document.querySelectorAll('*')));
    // document.querySelectorAll 은 프로토콜을 따르기 때문
    const it = document.querySelectorAll('*')[Symbol.iterator]();
    log(it.next());
    log(it.next());
    log(it.next());
    log(it.next());
    log(it.next()); // 잘 동작함을 확인할 수 있음
    // 따라서 map함수는 iterable protocol을 따르면 동작한다

    function* gen() {
      yield 2;
      if (false) yield 3;
      yield 4;
    }
    log(map(a => a * a, gen()));
    // 문장 역시도 사용 가능하다, 사실상 모든 것들을 map을 사용할 수 있다

    // document와 같은 브라우저 헬퍼함수도 이터러블 프로토콜을 따르기 때문에 앞으로 유연한, 다형성 높은 코딩을 할 수 있을것

  </script>

  <!-- 이터러블 프로토콜을 따른 map의 다형성2 -->
  <script>

    // 이터러블 프로토콜을 따랐을때의 조합성
    // 예를들어 map이라는 값이 있다(k : v), 이터러블
    let m = new Map();
    m.set('a', 10);
    m.set('b', 20);
    const it2 = m[Symbol.iterator](); // Symbol.iterator의 내용은 알지
    log(it2.next());
    log(it2.next());

    // 조회가 됨 >> map에 사용 가능, 아래처럼 새로운 객체를 만들 수도 있다(조합성 좋다~는 얘기)
    log(new Map(map(([k, a]) => [k, a * 2], m)));

  </script>

  <!-- filter -->
  <script>

    // filter: 걸러내는애임
    const filter = (iter) => {
      let res = [];
      for (const a of iter) {
        if (f(a)) res.push(a);
      }
      return res;
    }

    log(...filter(p => p.price < 20000, products));

    // 또 다른 예들
    log(filter(n => n % 2, [1, 2, 3, 4]));

    log(filter(n => n % 2, function* () {
      yield 1;
      yield 2;
      yield 3;
      yield 4;
      yield 5;
    }))

  </script>

  <!-- reduce -->
  <script>

    // 축약, 하나로 만드는 것
    const nums = [1, 2, 3, 4, 5];

    let total = 0;
    for (const n of nums) {
      total = total + n;
    }
    log(total); // 특정 값들 순회하며 하나로 축약할 때 쓰인다

    const reduce = (f, acc, iter) => {
      if (!iter) {
        iter = acc[Symbol.iterator]();  // 이터러블을 이터레이터로 만들고
        acc = iter.next().value;
      }
      for (const a of iter) {
        acc = f(acc, a);
      }
      return acc; // 외부세상 변경 않고 리턴
    };
    const add = (a, b) => a + b;
    log(reduce(add, 0, [1, 2, 3, 4, 5]));
    // 내부 구동은 재귀적으로 add(add(add(add(0, 1), 2), 3), 4) 이런식이다

    // 초기값을 빼면 아래처럼 구동됨
    // add, 0, [1, 2, 3, 4, 5]
    // add, 1, [2, 3, 4, 5]

  </script>

  <!-- reduce2 -->
  <script>

    // 보조함수를 이용해 어떻게 축약할지를 완전 위임한다
    log(reduce((total_price, product) => total_price + product.price,
      0,
      products));

  </script>

  <!-- map+filter+reduce 중첩 사용과 함수형 사고 -->
  <script>
    const add1 = (a, b) => a + b;

    // 가격을 뽑기 원한다
    log(map(p => p.price, products));

    // 특정 조건을 맞춘 애들의 금액만, 다 더해서 뽑고싶다
    log(
      reduce(
        add,
        map(p => p.price,
          filter(p => p.price < 20000, products))));

    // 이처럼 해도 같은얘기
    log(
      reduce(
        add,
        filter(n => n < 20000,
          map(p => p.price, products))));

    // reduce(add, 숫자로 평가가 될 것을 기대하는 요소 진입)

  </script>

</body>

</html>