<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>제너레이터와 이터레이터</title>
</head>

<body>
  <script>const log = console.log;</script>

  # 제너레이터/이터레이터
  - 제너레이터: 이터레이터이자 이터러블을 생성하는 함수

  <script>
    // 제너레이터는 일반함수의 앞에 *을 붙여 만든다

    function* gen() {
      yield 1;
      if (false) yield 2; // 제너는 순회할 값을 문장으로 표현한다고도 말할 수 있다
      yield 3;

      // return을 넣는 경우, 순회시 return은 순회하지 않는다
      return 100;
      // done이 true가 되며 return이 나옴
    }
    // 제너레이터는 이터레이터를 반환한다
    let iter = gen();
    // 이터레이터는 이터레이터이자 이터러블이다
    // 전 강의에서 설명했듯 실행 결과는 자기 자신
    // 제너레이터 >> well formed iterator를 리턴하는 함수
    // yield를 통해 몇 번의 next를 통해 값을 꺼낼지 정할 수 있다
    log(iter[Symbol.iterator]);
    log(iter.next());
    log(iter.next());
    log(iter.next());
    log(iter.next());


    // 제너레이터의 실행 결과는 이터레이터이자 이터러블이기 때문에
    // 순회할 수 있다
    for (const a of gen()) log(a);


    /*
      js에서 어떠한 값이든 이터러블이면 순회가 가능
      제너레이터는 그러한 문장을 값으로 만들 수 있고 문장을 통해 순회할 수 있는 값을 만들 수 있기에
      어떠한 값이든 순회할 수 있게 만든다는 (함수형 프로그래밍에서)상징적 의미가 있음

      제너레이터를 통해 어떠한 값이든 순회할 수 있는 형태로 조작할 수 있으며
      다양한 값들을 순회할 수 있는 이터러블을 쉽게 프로그래머가 로직을 만들어갈 수 있다는 이야기
    */
  </script>


  # odds

  <script>
    // 제너레이터를 활용해 홀수만 계속 발생시키는 이터레이터를 만들어 순회하는 예제
    /*
    function *odds(){
      yield 1;
      yield 3;
      yield 5;
    }
    let iter2 = odds();
    log(iter2.next());
    log(iter2.next());
    log(iter2.next());
    log(iter2.next());
    */
    // 동작하는 모습을 확인할 수 있다.

    // 지금은 yield를 추가하여 출력하게 되지만 이를 자동화 시켜보자면
    /*
    function* odds(l) {
      // 물론 2씩 증가시키면서 가는 것이 더 효율적이나 지금은 제너레이터를 활용하기 위한 예제
      for (let i = 0; i < l; i++) {
        if (i % 2) yield i;
      }
    }
    let iter2 = odds(10); // limit 설정
    log(iter2.next());
    log(iter2.next());
    log(iter2.next());
    log(iter2.next());
    log(iter2.next());
    log(iter2.next());
    log(iter2.next());  // 10까지 홀수가 잘 나오는 모습
    */

    // 좀 더 다른식으로 표현해보자
    function* infinity(i = 0) {
      while (true) yield i++;
    }
    // let iter3 = infinity();
    // iter3.next(); 를 통해 무한히 생성한다. 평가할 때 까지만 동작하기에 브라우저나 프로그램이 멈추지 않아

    // 무한수열을 이용한 홀수 생성
    function* odds(l) {
      for (const a of infinity(l)) {
        if (a % 2) yield a;
        if (a == l) return;  // 같을때 나가겠다
      }
    }

    // 조금 더 변동을 줘보자
    // iter(이터러블)을 받아 일하다가 받아둔 l과 만나면 더이상 동작하지 않는다
    function* limit(l, iter) {
      for (const a of iter) {
        yield a;
        if (a == l) return;
      }
    }
    let iter4 = limit(4, [1, 2, 3, 4, 5, 6]);
    iter4.next();

    // 잘 되는가 확인
    for (const a of odds(40)) log(a);

  </script>


  # for of, 전개 연산자, 구조 분해, 나머지 연산자

  <script>
    log(...odds(10));
    log([...odds(10), ...odds(20)]);

    const [head, ...tail] = odds(5);
    log(head);
    log(tail);

    const [a, b, ...rest] = odds(10);
    log(a);
    log(b);
    log(rest);
  </script>

</body>

</html>