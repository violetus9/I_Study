<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ES6에서 순회와 이터러블:이터레이터 프로토콜</title>
</head>

<body>

  <script>const log = console.log;</script>

  ## 기존과 달라진 ES6에서의 리스트 순회
  - for i++
  - for of

  <script>
    // ES5에선 아래와 같았다
    const list = [1, 2, 3];
    for (let i = 0; i < list.length; i++) {
      // log(list[i]);
    }
    // length라는 프로퍼티에 의존하여 숫자 키 i 로 접근하여 순회했었다.
    // 유사배열도 아래와 같이 비슷했다
    const str = 'abc';
    for (let i = 0; i < str.length; i++) {
      // log(str[i]);
    }

    // ES6 에서의 순회는?
    for (const a of list) {
      // log(a);
    }
    for (const a of str) {
      // log(a);
    }
    // 보다 간결하게 만든 것 이상의 의미들을 알아보자
  </script>


  ### Array를 통해 알아보기

  <script>
    log('Arr -------------');
    const arr = [1, 2, 3];
    // Symbol은 어떤 객체의 키로 사용될 수 있다.
    // log(arr[Symbol.iterator]);
    // 어떤 함수라고 나온다. 그걸 지워보고 순회가 되나 확인해보면
    // arr[Symbol.iterator] = null;
    // 결과는 에러 발생. 순회가 되지 않음 array가 iterable이 아니다.
    // for of 와 sym.itera~~ 함수가 연관이 있을 수 있다~
    // set, map 역시 마찬가지

    for (const a of arr) log(a);
  </script>


  ### Set을 통해 알아보기

  <script>
    log('Set -------------');
    const set = new Set([1, 2, 3]);
    for (const a of set) log(a);
    // array의 경우 [key] 의 값으로 접근이 가능하나, set은 불가능.
    // 기존의 for문과 내부적으로 방법이 다르다는 것을 말한다
  </script>


  ### Map을 통해 알아보기

  <script>
    log('Map -------------');
    const map = new Map([['a', 1], ['b', 2], ['c', 3]]);
    for (const a of map) log(a);
    // 이 경우 keys를 통해 이터레이터를 리턴하고, next() 실행시 vlaue에 키값만 담게 된다.
    // for(const a of map.keys()) log(a);
    // 실행하면 key만 뽑아올 수 있다는 것을 확인할 수 있다(이터레이터를 리턴)
    // value(), entries() 도 있어 해봐

  </script>


  ## 이터러블/이터레이터 프로토콜
  - 이터러블: 이터레이터를 리턴하는 [Symbol.iterator]() 를 가진 값
  - 이터레이터: { value, done } 객체를 리턴하는 next() 를 가진 값
  - 이터러블/이터레이터 프로토콜: 이터러블을 for...of, 전개 연산자 등과 함께 동작하도록 한 규약

  <script>
    let iterator = arr[Symbol.iterator]();
    // 실행한다면 {value, done}의 형태로 리턴됨 >> 이터레이터
    // 순회가 끝나면 done이 true
    // 즉 array,... 는 이터러블이며 이터레이터를 반환한다~ 가 됨
    iterator.next();
    // >> {value, done}
    // const a 의 a에 value에 해당하는 값을 넣어 뱉어냄

    // set 또한 마찬가지, 숫자로 접근할 수 없음에도 불구하고 이터러블 프로토콜을 따르기 때문에 동작
    // set[Symbol.iterator](); 의 .next() 실행시 array와 같은 방식으로 동작
  </script>


  ### 사용자 정의 이터러블을 통해 알아보기

  <script>
    // 이터레이터를 실행했을때, for of 로 순회했을때
    // value로 3, 2, 1 리턴하고 끝나는 이터러블을 만든다
    const iterable = {
      [Symbol.iterator]() {
        let i = 3;
        return {
          next() {
            return i == 0 ? { done: true } : { value: i--, done: false };
          },
          // 요부분 지우면 well formed 가 아니게 된다 확인할것
          [Symbol.iterator]() {
            return this;
          }
        }
      }
    };
    // let iterator = iterable[Symbol.iterator]();
    // log(iterator.next()); 로 내부 조회 가능
    // log(iterator.next());
    // log(iterator.next());
    // log(iterator.next());
    // for (const a of iterable) log(a);

    // 잘 구현된 이터러블의 경우에는 이터레이터를 만들어서 진행하여 순행할 수도 있고
    // 그대로 for of 에 넣었을 때 모든 값을 순회할 수 있도록 되어있다
    // const arr2 = [1, 2, 3];
    // let iter2 = arr2[Symbol.iterator]();
    // iter2.next();
    // log(iter2[Symbol.iterator]() == iter2);
    // 위의 경우 자기 자신을 반환하는 sym.iter메소드를 가지고 있을 때, well formed 이터레이터, 이터러블 이라 한다
    // for (const a of iter2) log(a);

    // js 환경인 브라우저 web apis 등 여러 구현된 값들은 이 프로토콜을 따르고 있다
    // 예를들면 아래처럼 순회가 가능
    for (const a of document.querySelectorAll('*')) log(a);
    const all = document.querySelectorAll('*');
    log(all[Symbol.iterator]);
    // all이라는 값이 배열이어서가 아닌, sym.it~가 구현이 되어있기 때문이고
    let iter3 = all[Symbol.iterator]();
    log(iter3.next());
    log(iter3.next());
    log(iter3.next());
  </script>


  ## 전개 연산자(또한 프로토콜을 따름)

  <script>
    const a = [1, 2];
    a[Symbol.iterator] = null;
    log([...a, ...[3, 4], ...arr, ...set, ...map]);
  // arr, set, map 역시 모두 사용할 수 있다
  </script>

</body>

</html>