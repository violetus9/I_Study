<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Arrow function 의 this context</title>
</head>

<body>

  <p>mydiv</p>

  <script>

    // this context of Arrow function
    // 보통 context문제 때문에 bind함수를 많이 쓴다   ?
    const myObj = {
      runTimeout() { // 키밸류로, 컴마로 만들지 않고 이렇게 object를 쉽게 만들수 있다 (in ES6)
        setTimeout(function () {
          console.log(this === window);
          this.printData();   // 이 경우 this가 가르키는 대상이 이 객체가 아니므로 오류출력,
        }.bind(this), 200);   // >> 위 경우를 고치기 위해 bind(this)를 추가하여
      },

      printData() {
        console.log('hi hi ~');
      }
    }

    myObj.runTimeout(); // true, this는 window를 가리킨다

    // arrow 함수의 this context가 어떻게 바뀌었는지 알아보자
    const myArow = {
      runTimeout() {
        setTimeout(() => {
          console.log(this === window);   // false!!!!!!!!!!!!
          this.printData();     // bind를 생략했는데 잘 나온다
        }, 200);
      },
      printData() {
        console.log('bind 생략인데??');
      }
    }
    // 왜 bind를 생략해도 나왔을까?
    // this가 가르키는 대상은 실행타이밍에 가르키는건데, 이벤트 큐에 있다가 나중에 실행되는거라 당연히 window를 가르켜야 하나
    // >> arrow는 context를 유지하고 있어서 선언 기준으로 ㅇㅇ 대충 이런 장점이 이씀

    const el = document.querySelector("p");
    el.addEventListener('click', function (evt) {
      console.log(this)
    });
    // html paragraphelement > p태그를 가리키고 있다

    const myObj1 = {  // 오브젝트 리터럴
      register() {
        el.addEventListener('click', (evt) => {
          this.printData(evt.target); // bind 없이, 호출하는거에서 바뀌지 않고 this선언기준의 가리키는걸로 결정이 됨
        });
      },

      printData(el) {
        console.log('clicked!', el.innerText);
      }
    }

    myObj1.register();
    // 이런경우 mydiv가 context기에 찍힘

  </script>

</body>

</html>