<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Function</title>
</head>

<body>

  <!-- Arrow function 활용 -->
  <script>

    // func.
    // setTimeout(function() {
    //   console.log('settimeout!');
    // }, 1000);

    setTimeout(() => {
      console.log('settimeout arrow');
    }, 1000);
    // 요경우 반환값이 있는 경우도 더 축약해서 효율적으로 짤 수 있음

    let newArr = [1, 2, 3, 4, 5].map(function (value, index, object) {
      return value * 2;
    });
    console.log(newArr);  // 여서 index는 쓰지 않았음
    // 콜백함수의 문제점 > 어느 함수의 인자로 들어가는데 인자에 있는 함수가 너무 길다
    // 밖으로 구현할 수도 있지만 뭐, 화살표 이용하면 편리

    let newArr1 = [1, 2, 3, 4, 5].map((v) => {
      return v * 2;
    }); // 리턴이 필요 없는 경우 생략 후 v*2 까지만 나오게 해도 된다
    console.log('arrow newArr1', newArr1);

  </script>

  <!-- Arrow function 의 this context -->
  <script>

    // this context of Arrow function
    // 보통 context문제 때문에 bind함수를 많이 쓴다   ?
    const myObj = {
      runTimeout() { // 키밸류로, 컴마로 만들지 않고 이렇게 object를 쉽게 만들수 있다 (in ES6)
        setTimeout(function () {
          console.log(this === window);
          this.printData();   // 이 경우 this가 가르키는 대상이 이 객체가 아니므로 오류출력,
        }.bind(this), 200);              // >> 위 경우를 고치기 위해 bind(this)를 추가하여
      },

      printData() {
        console.log('hi hi ');
      }
    }

    myObj.runTimeout(); // true, this는 window를 가리킨다

    // arrow 함수의 this context가 어떻게 바뀌었는지 알아보자
    const myArow = {
      runTimeout() {
        setTimeout(() => {
          console.log(this === window);   // false!!!!!!!!!!!!
          this.printData();     // bind를 생략했는데 잘 나온다
        }, 200);
      },
      printData() {
        console.log('bind 생략인데??');
      }
    }
    // 왜 bind를 생략해도 나왔을까?
    // this가 가르키는 대상은 실행타이밍에 가르키는건데, 이벤트 큐에 있다가 나중에 실행되는건데 당연히 window를 가르켜야 하나
    // >> arrow는 context를 유지하고 있어서 선언 기준으로 ㅇㅇ 대충 이런 장점이 이씀

  </script>

  <!-- function default paramaters -->
  <script>

    // default parameters
    // function sum(val, size) {
    //   return val * size;
    // }
    // console.log(sum(3,10));   // 10을 전달하지 않고 (3) >> NaN 나옴

    // 선언부에서 설정을 해 줄 수 있따
    function sum(val, size = 1) { // 이런걸 default parameter~라 함
      return val * size;
    }
    console.log(sum(3, 10));

    // size={value:1} >> 오브젝트로도 생성 가능
    // 이경우라면 당연히 size.value 로 지칭을 해줘야겠지

  </script>

  <!-- rest paramaters -->
  <script>
    // 이런거들 말고도 더 많으니가 찾아보셍(default, rest, .....많대)

    // 들어오는 인자의 값이 숫자인가를 체크하는 함수를 만들고 싶다, 인자가 몇개가 올지 모른다?
    function checkNum() {
      // arguments 가 있지만, 얘는 배열이 아니라, 배열에대한 함수를 쓸 수는 없서, 지금은 every를 쓰고싶어
      const argArray = Array.prototype.slice.call(arguments);
      console.log(toString.call(argArray));  // 타입을 보면 array가 되어씀
      const result = argArray.every((v) => typeof v === 'number');
    }
    const result = checkNum(10, 2, 3, 4, 5, '55');
    const result1 = checkNum(4, 5, '55');

    // 이렇게 진짜배열로 바꿔서 했는데 사실 (...argArray) 하면 그냥; 된다
    // spread operator 과 헷갈리지 않도록 하자 둘은 엄연히 다른 개념이래

  </script>

</body>

</html>