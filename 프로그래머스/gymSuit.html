<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>체육복</title>
</head>

<body>

  <script>

    function solution(n, lost, reserve) {
      let answer = n;
      let tmpLost = [...lost];
      // 학생 수, 잃은 학생 배열, 여벌 학생 배열 순으로 인자 넘어옴

      // reserve에서 lost를 빼 > 빌려줌가능, 진짜없는 배열추출
      let delStack = ((i) => {
        (reserve.includes(i)) ? reserve.splice(reserve.indexOf(i), 1) : '';
        (tmpLost.includes(i)) ? tmpLost.splice(tmpLost.indexOf(i), 1) : '';
      });
      // 없는 애들한테 빌려주기
      let delStack2 = ((i) => {
        (reserve.includes(i)) ? reserve.splice(reserve.indexOf(i), 1) : '';
      });

      // 여분이 있는 아이가 잃었을때, 빌려줄 수 없게된다
      for (const i of lost) {
        (reserve.includes(i)) ? delStack(i) : '';
      }

      lost = [...tmpLost];

      for (const i of tmpLost) {
        let tmpResr = reserve.length;
        (reserve.includes(i - 1)) ? delStack2(i - 1) :
          (reserve.includes(i + 1)) ? delStack2(i + 1) :
            '';
        (tmpResr !== reserve.length) ? lost.splice(lost.indexOf(i), 1) : '';
      }

      return answer - lost.length;
    }

    // 삼항연산은 블록문을 생성할 수 없기에 전역변수 참조는 가능하나 지역변수 생성이 불가능

    // indexOf 는 없는 요소를 탐색하면 -1을 반환하며 -1인덱스틑 배열의 마지막부터라는 말

  </script>

</body>

</html>